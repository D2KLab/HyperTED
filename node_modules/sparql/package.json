{
  "name": "sparql",
  "description": "Simple, low-level SPARQL client",
  "version": "0.1.3",
  "maintainers": [
    {
      "name": "Aldo Bucchi",
      "email": "aldo.bucchi@gmail.com"
    },
    {
      "name": "Herman A. Junge",
      "email": "haj@neosource.cl"
    }
  ],
  "dependencies": {
    "request": "1.9.0",
    "coffee-script": "1.2.x"
  },
  "keywords": [
    "sparql",
    "rdf",
    "linkeddata"
  ],
  "directories": {
    "lib": "./lib"
  },
  "engines": {
    "node": ">= 0.2.6"
  },
  "readme": "Simple SPARQL HTTP Client library for Node.js\n=============================================\n\nGetting Started\n--------------------\n\n### Install\n\n    npm install sparql\n\n### Use\n\n    sparql = require 'sparql'\n    client = new sparql.Client 'http://dbpedia.org/sparql'\n    client.query 'select * where { ?s ?p ?o } limit 100', (err, res) ->\n      console.log res\n\nThe result of calling the query() function will be a raw object conforming to the SPARQL-JSON[1] results format. \n\nCore API\n--------------------\n\n### query\n\nLow level function. Returns the complete [SPARQL-JSON][sparql-json] results object.\n\n    client.query 'select * where {?s ?p ?o} limit 10', (err, res) ->\n      console.log row.s for row in res.results.bindings\n\nConvenience Query Methods\n------------------------------\n\n### rows\n\nConvenience method to get to the rows directly. Builds on top of sparql.query, like most of the\nother query methods.\n\n    client.rows 'select * where {?s ?p ?o} limit 10', (err, res) ->\n      console.log row.s for row in res\n\n### row\n\nConvenience method that only returns the first row in the result set\n\n    client.row 'select * where {?s ?p ?o} limit 10', (err, res) ->\n      console.log res.s\n\n### col\n\nConvenience method that returns an array of with the first value of each row\n\n    client.col 'select distinct ?name where {?s foaf:name ?name} limit 10', (err, res) ->\n      console.log( rdf_value.value ) for rdf_value in res\n\nWhat's with the rdf_value.value part?\nRead the [SPARQL-JSON][sparql-json] results format specification page.\n\n### cell\n\nConvenience method that returns only the first binding of the first row or NULL\n\n    client.col 'select ?name where {?s foaf:name ?name} limit 1', (err, res) ->\n      console.log res\n\n\nConvenience Update Methods\n------------------------------\n\nThere are a bunch of higher level methods that generate SPARQL for you.\nI am providing a small number of such methods, as I don't want this library to grow into something like Active Record.\n\nWriting SPARQL by hand is highly encouraged.\n\n### set\n\nProvide an abstraction atop a simple 'entity oriented' operation that is not so simple when you are working with SPARQL.\n\nImagine you want to do something like this, conceptually speaking:\n\n    aldo.name = 'Aldo'\n\nYou can get that with one simple call to the API\n\n    client.set '<urn:test:graph>', '<urn:test:aldo>', '<urn:test:name>', '\"Aldo\"', no, (err, res) ->\n      console.log 'Aldo is now named Aldo, hooray!' \n\nNot so simple? Well, compare that to the SPARQL Update statement that gets generated under the covers:\n\n    modify <urn:test:graph> \n      delete { <urn:test:aldo> <urn:test:name> ?x } \n      insert { <urn:test:aldo> <urn:test:name> \"Aldo\" } \n      where { optional{ <urn:test:aldo> <urn:test:name> ?x } }\n\nNotice that, if `<urn:test:aldo>` had a previous `<urn:test:name>`, it will be replaced. If it doesn't, then a new triple will be inserted.\n\nYou can also delete a value by setting it to null ( effectively removing one or more triples )\n\n    client.set '<urn:test:graph>', '<urn:test:aldo>', '<urn:test:name>', null, no, (err, res) ->\n      console.log 'Aldo went back to anonimity'\n\nIn this case, the generated SPARQL is:\n\n    delete from <urn:test:graph>\n      { <urn:test:aldo> <urn:test:name> ?x }\n      where { <urn:test:aldo> <urn:test:name> ?x }\n\nThe 5th parameter is a boolean flag indicating whether the triple patterns should be inverted ( useful for when you only have the reversed predicate )\n\n### mset\n\nOne Subject, several pairs Predicate-Object \n\nLet's group some attributes of an user\n\n\tattributes = \n\t\t'<urn:test:username>' : 'haj'\n\t\t'<urn:test:password>' : '123'\n\t\t'<urn:test:name>' : 'Herman'\n\nAnd we invoke mset\n\t\n\tclient.mset  '<urn:test:graph>', <urn:test:haj>', attributes, (err, res) ->\n\t\tif err?\n\t\t\tconsole.log 'Success'\n\t\telse\n\t\t\tconsole.log 'Error: ' + err\n\nThe SPARQL query generated is:\n\n\tINSERT INTO <urn:test:graph>\n\t\t{ <urn:test:haj> \t<urn:test:username> \t'Haj';\n\t\t\t\t\t\t\t<urn:test:password>\t\t'123';\n\t\t\t\t\t\t\t<urn:test:name>\t\t\t'Herman'. }\n\nTests\n--------------------\n\n### Test Dependencies\n\nYou must have [OpenLink Virtuoso](http://virtuoso.openlinksw.com/dataspace/dav/wiki/Main/) >= 6.1.2 installed and `virtuoso`, `isql` in your path.\n\nAlso, maybe you have to set Virtuoso to allow INSERT and DELETE to be done via sparql:\n\n\t$ isql\n\tSQL> grant execute on DB.DBA.SPARQL_MODIFY_BY_DICT_CONTENTS to \"SPARQL\";\n\n\nYou must also have expresso\n    npm install expresso\n\n### Running the Tests\n\n(Coming Soon)\n\n\n[sparql-json]: http://www.w3.org/TR/rdf-sparql-json-res/\n\n\n",
  "readmeFilename": "README.md",
  "_id": "sparql@0.1.3",
  "dist": {
    "shasum": "d8404e95ad2933697a77c52e44addb8472f23e45"
  },
  "_from": "sparql@^0.1.3",
  "_resolved": "https://registry.npmjs.org/sparql/-/sparql-0.1.3.tgz"
}
